# åµŒå¥—è¯„è®ºç³»ç»Ÿå®Œæ•´å®ç°æ–‡æ¡£

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜äº†åµŒå¥—è¯„è®ºç³»ç»Ÿçš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬æ•°æ®åº“è®¾è®¡ã€APIå®ç°ã€UIç»„ä»¶å’Œè¯„è®ºç‚¹èµåŠŸèƒ½ã€‚ç³»ç»Ÿæ”¯æŒæœ€å¤š3å±‚åµŒå¥—è¯„è®ºï¼Œæä¾›æµç•…çš„ç”¨æˆ·ä½“éªŒå’Œé«˜æ€§èƒ½çš„æ•°æ®å¤„ç†ï¼Œç¬¦åˆä¸šå†…ç¤¾äº¤åª’ä½“ï¼ˆTwitter/X, Reddit, YouTubeï¼‰çš„æœ€ä½³å®è·µã€‚

## ğŸ¯ å®ç°ç›®æ ‡

- âœ… æ”¯æŒè¯„è®ºçš„è¯„è®ºï¼ˆåµŒå¥—è¯„è®ºï¼‰
- âœ… æœ€å¤šæ”¯æŒ3å±‚åµŒå¥—
- âœ… å®Œæ•´çš„è¯„è®ºç‚¹èµåŠŸèƒ½
- âœ… ä¼˜é›…çš„UIå±•ç¤ºå’Œäº¤äº’
- âœ… ä¸å½±å“ç°æœ‰æ ¸å¿ƒåŠŸèƒ½
- âœ… ç¬¦åˆä¸šå†…æœ€ä½³å®è·µ

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### 1. Interactionsè¡¨ç»“æ„

åœ¨åŸæœ‰çš„`interactions`è¡¨ä¸­æ·»åŠ äº†åµŒå¥—è¯„è®ºæ”¯æŒï¼š

```sql
-- äº’åŠ¨è¡¨ï¼ˆç‚¹èµã€è¯„è®ºã€åˆ†äº«ã€æ”¶è—ï¼‰
CREATE TABLE public.interactions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  target_id UUID NOT NULL,
  target_type VARCHAR(20) NOT NULL CHECK (target_type IN ('card', 'comment', 'chapter', 'quest')),
  type VARCHAR(20) NOT NULL CHECK (type IN ('like', 'unlike', 'comment', 'reply', 'share', 'repost', 'unrepost', 'bookmark', 'unbookmark', 'quote')),
  
  -- è¯„è®ºå†…å®¹
  content TEXT,
  
  -- åµŒå¥—è¯„è®ºæ”¯æŒ
  parent_id UUID REFERENCES public.interactions(id) ON DELETE CASCADE,
  reply_count INTEGER DEFAULT 0 CHECK (reply_count >= 0),
  
  -- æ—¶é—´æˆ³
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- çº¦æŸï¼šè¯„è®ºå¿…é¡»æœ‰å†…å®¹
  CONSTRAINT check_comment_content CHECK (
    (type IN ('comment', 'reply') AND content IS NOT NULL AND length(trim(content)) > 0)
    OR type NOT IN ('comment', 'reply')
  ),
  
  -- çº¦æŸï¼šreplyç±»å‹å¿…é¡»æœ‰parent_id
  CONSTRAINT check_reply_parent CHECK (
    (type = 'reply' AND parent_id IS NOT NULL)
    OR type != 'reply'
  )
);
```

### 2. ç´¢å¼•ä¼˜åŒ–

```sql
-- äº’åŠ¨ç´¢å¼•
CREATE INDEX idx_interactions_target ON public.interactions(target_id, target_type);
CREATE INDEX idx_interactions_user ON public.interactions(user_id, type);
CREATE INDEX idx_interactions_created ON public.interactions(created_at DESC);
CREATE INDEX idx_interactions_parent ON public.interactions(parent_id) WHERE parent_id IS NOT NULL;

-- éƒ¨åˆ†å”¯ä¸€ç´¢å¼•ï¼šä»…å¯¹like/bookmark/repostç”Ÿæ•ˆï¼Œå…è®¸åŒä¸€ç”¨æˆ·å¤šæ¬¡è¯„è®º
CREATE UNIQUE INDEX idx_interactions_unique_actions 
ON public.interactions(user_id, target_id, target_type, type)
WHERE type IN ('like', 'bookmark', 'repost');
```

### 3. è§¦å‘å™¨å’Œå‡½æ•°

#### è‡ªåŠ¨æ›´æ–°reply_countè§¦å‘å™¨

```sql
CREATE OR REPLACE FUNCTION update_interaction_reply_count()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- æ–°å¢å›å¤æ—¶ï¼Œæ›´æ–°çˆ¶è¯„è®ºçš„reply_count
    IF NEW.parent_id IS NOT NULL AND NEW.type = 'reply' THEN
      UPDATE public.interactions
      SET reply_count = reply_count + 1
      WHERE id = NEW.parent_id;
    END IF;
    RETURN NEW;
    
  ELSIF TG_OP = 'DELETE' THEN
    -- åˆ é™¤å›å¤æ—¶ï¼Œå‡å°‘çˆ¶è¯„è®ºçš„reply_count
    IF OLD.parent_id IS NOT NULL AND OLD.type = 'reply' THEN
      UPDATE public.interactions
      SET reply_count = GREATEST(reply_count - 1, 0)
      WHERE id = OLD.parent_id;
    END IF;
    RETURN OLD;
  END IF;
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER trigger_update_reply_count
  AFTER INSERT OR DELETE ON public.interactions
  FOR EACH ROW
  EXECUTE FUNCTION update_interaction_reply_count();
```

#### è·å–è¯„è®ºæ ‘å‡½æ•°

```sql
CREATE OR REPLACE FUNCTION get_comment_tree(
  p_target_id UUID,
  p_target_type VARCHAR(20),
  p_max_depth INTEGER DEFAULT 3
)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  target_id UUID,
  target_type VARCHAR(20),
  type VARCHAR(20),
  content TEXT,
  parent_id UUID,
  reply_count INTEGER,
  depth INTEGER,
  path UUID[],
  created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
  RETURN QUERY
  WITH RECURSIVE comment_tree AS (
    -- åŸºç¡€æŸ¥è¯¢ï¼šè·å–ä¸€çº§è¯„è®º
    SELECT 
      i.id,
      i.user_id,
      i.target_id,
      i.target_type,
      i.type,
      i.content,
      i.parent_id,
      i.reply_count,
      0 as depth,
      ARRAY[i.id] as path,
      i.created_at
    FROM public.interactions i
    WHERE i.target_id = p_target_id
      AND i.target_type = p_target_type
      AND i.type = 'comment'
      AND i.parent_id IS NULL
    
    UNION ALL
    
    -- é€’å½’æŸ¥è¯¢ï¼šè·å–åµŒå¥—å›å¤
    SELECT 
      i.id,
      i.user_id,
      i.target_id,
      i.target_type,
      i.type,
      i.content,
      i.parent_id,
      i.reply_count,
      ct.depth + 1,
      ct.path || i.id,
      i.created_at
    FROM public.interactions i
    INNER JOIN comment_tree ct ON i.parent_id = ct.id
    WHERE ct.depth < p_max_depth
      AND i.type = 'reply'
  )
  SELECT * FROM comment_tree
  ORDER BY path, created_at ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## ğŸ”§ APIå±‚å®ç°

### 1. ç±»å‹å®šä¹‰ (`src/types/feed.ts`)

```typescript
// Comment types for nested comments
export interface Comment {
  id: string;
  userId: string;
  targetId: string;
  targetType: 'card' | 'comment' | 'chapter' | 'quest';
  type: 'comment' | 'reply';
  content: string;
  parentId?: string;
  replyCount: number;
  depth: number;
  author: Author;
  createdAt: string;
  // Nested replies
  replies?: Comment[];
  // Viewer interaction state
  viewer?: {
    liked: boolean;
  };
  stats?: {
    likes: number;
  };
}

export interface CommentTree {
  comments: Comment[];
  totalCount: number;
  hasMore: boolean;
  cursor?: string;
}

// Thread data for detail page
export type ThreadPost = FeedCard & {
  replyCount: number;
  replies?: ThreadPost[];
  hasHiddenReplies?: boolean;
};

export interface PostThread {
  post: ThreadPost;
  parent?: ThreadPost;
  replies?: ThreadPost[];
  ancestors?: ThreadPost[];
}
```

### 2. APIå‡½æ•° (`src/lib/api/feed.ts`)

#### åˆ›å»ºè¯„è®ºï¼ˆæ”¯æŒåµŒå¥—ï¼‰

```typescript
export async function createComment(
  postId: string,
  content: string,
  parentId?: string
): Promise<void> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 300));

  if (MOCK_DATA_ENABLED) {
    const mockUser = {
      id: 'currentUser',
      handle: 'you',
      displayName: 'You',
      avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=you',
    };
    
    // Store comment in session storage
    const comment = commentStorage.add({
      postId,
      content,
      author: mockUser,
      parentId,
    });
    
    return;
  }

  // Supabase implementation
  try {
    const supabase = getSupabaseClient();
    if (!supabase) {
      throw new Error('Supabase client not initialized');
    }

    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      throw new Error('User not authenticated');
    }

    // Determine if this is a reply or a top-level comment
    const interactionType = parentId ? 'reply' : 'comment';
    const targetId = parentId || postId;
    const targetType = parentId ? 'comment' : 'card';

    // Insert comment/reply interaction
    const { error } = await (supabase as any)
      .from('interactions')
      .insert({
        user_id: user.id,
        target_id: targetId,
        target_type: targetType,
        type: interactionType,
        content: content,
        parent_id: parentId || null,
      });

    if (error) {
      console.error('[createComment] Error:', error);
      throw error;
    }

    // Update comment count on the post (only for top-level comments)
    if (!parentId) {
      const { error: updateError } = await (supabase as any)
        .from('feed_cards')
        .update({
          comments_count: (supabase as any).raw('comments_count + 1')
        })
        .eq('id', postId);

      if (updateError) {
        console.error('[createComment] Update count error:', updateError);
      }
    }

  } catch (error) {
    console.error(`Failed to create comment:`, error);
    throw error;
  }
}
```

#### åˆ›å»ºå›å¤

```typescript
export async function createReply(
  commentId: string,
  content: string
): Promise<void> {
  // Get the parent comment to find the post ID
  if (MOCK_DATA_ENABLED) {
    const mockUser = {
      id: 'currentUser',
      handle: 'you',
      displayName: 'You',
      avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=you',
    };
    
    commentStorage.add({
      postId: commentId, // In mock mode, we'll use commentId as postId
      content,
      author: mockUser,
      parentId: commentId,
    });
    
    return;
  }

  // Supabase implementation
  try {
    const supabase = getSupabaseClient();
    if (!supabase) {
      throw new Error('Supabase client not initialized');
    }

    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      throw new Error('User not authenticated');
    }

    // Get parent comment to find the post ID
    const { data: parentComment, error: parentError } = await (supabase as any)
      .from('interactions')
      .select('target_id')
      .eq('id', commentId)
      .single();

    if (parentError || !parentComment) {
      throw new Error('Parent comment not found');
    }

    // Insert reply
    const { error } = await (supabase as any)
      .from('interactions')
      .insert({
        user_id: user.id,
        target_id: commentId, // Reply targets the comment, not the post
        target_type: 'comment',
        type: 'reply',
        content: content,
        parent_id: commentId,
      });

    if (error) {
      console.error('[createReply] Error:', error);
      throw error;
    }

  } catch (error) {
    console.error(`Failed to create reply:`, error);
    throw error;
  }
}
```

#### è¯„è®ºç‚¹èµ/å–æ¶ˆç‚¹èµ

```typescript
export async function interactWithComment(
  commentId: string,
  action: 'like' | 'unlike'
): Promise<void> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 200));

  if (MOCK_DATA_ENABLED) {
    const mockUserId = 'currentUser';
    
    if (action === 'like') {
      interactionStorage.add({
        postId: commentId, // Using commentId as postId in mock mode
        type: 'like',
        userId: mockUserId,
      });
    } else {
      // Remove like
      const interactions = interactionStorage.getAll();
      const filtered = interactions.filter(
        i => !(i.postId === commentId && i.type === 'like' && i.userId === mockUserId)
      );
      if (typeof window !== 'undefined') {
        window.sessionStorage.setItem('user_interactions', JSON.stringify(filtered));
      }
    }
    return;
  }

  // Supabase implementation
  try {
    const supabase = getSupabaseClient();
    if (!supabase) {
      throw new Error('Supabase client not initialized');
    }

    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      throw new Error('User not authenticated');
    }

    if (action === 'like') {
      // Add like to comment
      const { error } = await (supabase as any)
        .from('interactions')
        .insert({
          user_id: user.id,
          target_id: commentId,
          target_type: 'comment',
          type: 'like',
        });

      if (error) {
        console.error('[interactWithComment] Like error:', error);
        throw error;
      }
    } else {
      // Remove like from comment
      const { error } = await (supabase as any)
        .from('interactions')
        .delete()
        .eq('user_id', user.id)
        .eq('target_id', commentId)
        .eq('target_type', 'comment')
        .eq('type', 'like');

      if (error) {
        console.error('[interactWithComment] Unlike error:', error);
        throw error;
      }
    }

  } catch (error) {
    console.error(`Failed to ${action} comment:`, error);
    throw error;
  }
}
```

#### è·å–è¯„è®ºæ ‘ï¼ˆåŒ…å«ç‚¹èµæ•°æ®ï¼‰

```typescript
export async function fetchPostThread(postId: string): Promise<PostThread> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 500));

  if (MOCK_DATA_ENABLED) {
    // Mock implementation with nested comments
    const mockPost = mockPosts.find(p => p.id === postId);
    if (!mockPost) {
      throw new Error('Post not found');
    }

    // Get comment tree from session storage
    const commentTree = commentStorage.getCommentTree(postId);
    
    // Convert to ThreadPost format
    const convertCommentToThreadPost = (comment: StoredComment & { replies?: StoredComment[] }): ThreadPost => ({
      id: comment.id,
      type: 'text',
      content: comment.content,
      author: comment.author,
      stats: {
        replies: comment.replyCount || 0,
        reposts: 0,
        likes: 0,
        bookmarks: 0,
        views: 0,
      },
      viewer: {
        liked: false,
        reposted: false,
        bookmarked: false,
      },
      createdAt: comment.createdAt,
      reply: {
        root: { uri: postId, cid: postId },
        parent: { uri: postId, cid: postId },
      },
      replyCount: comment.replyCount || 0,
      replies: comment.replies ? comment.replies.map(convertCommentToThreadPost) : undefined,
    });

    const replies = commentTree.map(convertCommentToThreadPost);

    return {
      post: {
        ...mockPost,
        replyCount: replies.length,
        replies: replies.length > 0 ? replies : undefined,
      },
      replies,
    };
  }

  // Supabase implementation
  try {
    const supabase = getSupabaseClient();
    if (!supabase) {
      throw new Error('Supabase client not initialized');
    }

    // Get current user for viewer state
    const { data: { user } } = await supabase.auth.getUser();

    // Fetch post data
    const { data: postData, error: postError } = await (supabase as any)
      .from('feed_cards')
      .select(`
        *,
        author:profiles!feed_cards_author_id_fkey (
          id,
          username,
          display_name,
          avatar_url,
          level
        )
      `)
      .eq('id', postId)
      .single();

    if (postError || !postData) {
      throw new Error('Post not found');
    }

    // Get viewer interaction state
    let viewerState = {
      liked: false,
      bookmarked: false,
      reposted: false,
    };

    if (user) {
      const { data: interactions } = await (supabase as any)
        .from('interactions')
        .select('type')
        .eq('target_id', postId)
        .eq('target_type', 'card')
        .eq('user_id', user.id);

      if (interactions) {
        viewerState = {
          liked: interactions.some((i: any) => i.type === 'like'),
          bookmarked: interactions.some((i: any) => i.type === 'bookmark'),
          reposted: interactions.some((i: any) => i.type === 'repost'),
        };
      }
    }

    // Fetch replies (comments) with nested structure
    const { data: repliesData, error: repliesError } = await (supabase as any)
      .from('interactions')
      .select(`
        *,
        author:profiles!interactions_user_id_fkey (
          id,
          username,
          display_name,
          avatar_url,
          level
        )
      `)
      .eq('target_id', postId)
      .eq('target_type', 'card')
      .eq('type', 'comment')
      .is('parent_id', null)
      .order('created_at', { ascending: true });

    if (repliesError) {
      console.error('[fetchPostThread] Replies fetch error:', repliesError);
    }

    // Helper function to fetch comment likes count and viewer state
    const getCommentLikesInfo = async (commentId: string) => {
      // Get total likes count
      const { count: likesCount } = await (supabase as any)
        .from('interactions')
        .select('*', { count: 'exact', head: true })
        .eq('target_id', commentId)
        .eq('target_type', 'comment')
        .eq('type', 'like');

      // Check if current user liked this comment
      let userLiked = false;
      if (user) {
        const { data: userLike } = await (supabase as any)
          .from('interactions')
          .select('id')
          .eq('target_id', commentId)
          .eq('target_type', 'comment')
          .eq('type', 'like')
          .eq('user_id', user.id)
          .single();
        
        userLiked = !!userLike;
      }

      return { likesCount: likesCount || 0, userLiked };
    };

    // Helper function to recursively fetch nested replies
    const fetchNestedReplies = async (parentId: string, depth: number = 0, maxDepth: number = 3): Promise<ThreadPost[]> => {
      if (depth >= maxDepth) return [];

      const { data: nestedReplies } = await (supabase as any)
        .from('interactions')
        .select(`
          *,
          author:profiles!interactions_user_id_fkey (
            id,
            username,
            display_name,
            avatar_url,
            level
          )
        `)
        .eq('parent_id', parentId)
        .eq('type', 'reply')
        .order('created_at', { ascending: true });

      if (!nestedReplies || nestedReplies.length === 0) return [];

      const transformedReplies: ThreadPost[] = [];
      for (const reply of nestedReplies) {
        const likesInfo = await getCommentLikesInfo(reply.id);
        const childReplies = await fetchNestedReplies(reply.id, depth + 1, maxDepth);
        
        transformedReplies.push({
          id: reply.id,
          type: 'text',
          content: reply.content || '',
          author: {
            id: reply.author.id,
            handle: reply.author.username,
            displayName: reply.author.display_name || reply.author.username,
            avatar: reply.author.avatar_url,
            verified: reply.author.level >= 10,
          },
          stats: {
            replies: childReplies.length,
            reposts: 0,
            likes: likesInfo.likesCount,
            bookmarks: 0,
            views: 0,
          },
          viewer: {
            liked: likesInfo.userLiked,
            reposted: false,
            bookmarked: false,
          },
          createdAt: reply.created_at,
          reply: {
            root: { uri: postId, cid: postId },
            parent: { uri: parentId, cid: parentId },
          },
          replyCount: childReplies.length,
          replies: childReplies.length > 0 ? childReplies : undefined,
        });
      }

      return transformedReplies;
    };

    // Transform post data to FeedCard format
    const mainPost: ThreadPost = {
      id: postData.id,
      type: postData.type || 'text',
      content: postData.content?.text || '',
      author: {
        id: postData.author.id,
        handle: postData.author.username,
        displayName: postData.author.display_name || postData.author.username,
        avatar: postData.author.avatar_url,
        verified: postData.author.level >= 10,
      },
      stats: {
        replies: postData.comments_count || 0,
        reposts: postData.shares_count || 0,
        likes: postData.likes_count || 0,
        bookmarks: 0,
        views: postData.views_count || 0,
      },
      viewer: viewerState,
      createdAt: postData.created_at,
      media: postData.content?.media,
      novel: postData.metadata?.novel,
      replyCount: postData.comments_count || 0,
    };

    // Transform replies data with nested structure and likes info
    const replies: ThreadPost[] = [];
    for (const reply of (repliesData || [])) {
      const likesInfo = await getCommentLikesInfo(reply.id);
      const nestedReplies = await fetchNestedReplies(reply.id);
      
      replies.push({
        id: reply.id,
        type: 'text',
        content: reply.content || '',
        author: {
          id: reply.author.id,
          handle: reply.author.username,
          displayName: reply.author.display_name || reply.author.username,
          avatar: reply.author.avatar_url,
          verified: reply.author.level >= 10,
        },
        stats: {
          replies: nestedReplies.length,
          reposts: 0,
          likes: likesInfo.likesCount,
          bookmarks: 0,
          views: 0,
        },
        viewer: {
          liked: likesInfo.userLiked,
          reposted: false,
          bookmarked: false,
        },
        createdAt: reply.created_at,
        reply: {
          root: { uri: postId, cid: postId },
          parent: { uri: postId, cid: postId },
        },
        replyCount: nestedReplies.length,
        replies: nestedReplies.length > 0 ? nestedReplies : undefined,
      });
    }

    return {
      post: mainPost,
      replies,
    };

  } catch (error) {
    console.error(`Failed to fetch post thread:`, error);
    throw error;
  }
}
```

### 3. Session Storageæ”¯æŒ (`src/lib/utils/session-storage.ts`)

```typescript
interface StoredComment {
  id: string;
  postId: string;
  content: string;
  author: {
    id: string;
    handle: string;
    displayName: string;
    avatar: string;
  };
  parentId?: string;
  replyCount?: number;
  createdAt: string;
}

// è¯„è®ºå­˜å‚¨
export const commentStorage = {
  // è·å–æ‰€æœ‰è¯„è®º
  getAll(): StoredComment[] {
    if (typeof window === 'undefined') return [];
    const data = window.sessionStorage.getItem(STORAGE_KEYS.POST_COMMENTS);
    return safeParse(data, []);
  },

  // è·å–ç‰¹å®šå¸–å­çš„è¯„è®ºï¼ˆä»…é¡¶çº§è¯„è®ºï¼‰
  getByPostId(postId: string): StoredComment[] {
    return this.getAll().filter(comment => comment.postId === postId && !comment.parentId);
  },

  // è·å–ç‰¹å®šè¯„è®ºçš„å›å¤
  getRepliesByCommentId(commentId: string): StoredComment[] {
    return this.getAll().filter(comment => comment.parentId === commentId);
  },

  // è·å–è¯„è®ºæ ‘ï¼ˆåŒ…å«åµŒå¥—å›å¤ï¼‰
  getCommentTree(postId: string): StoredComment[] {
    const allComments = this.getAll().filter(c => c.postId === postId);
    const commentMap = new Map<string, StoredComment & { replies?: StoredComment[] }>();
    const topLevelComments: (StoredComment & { replies?: StoredComment[] })[] = [];

    // ç¬¬ä¸€éï¼šåˆ›å»ºæ‰€æœ‰è¯„è®ºçš„æ˜ å°„
    allComments.forEach(comment => {
      commentMap.set(comment.id, { ...comment, replies: [] });
    });

    // ç¬¬äºŒéï¼šæ„å»ºæ ‘ç»“æ„
    allComments.forEach(comment => {
      const commentWithReplies = commentMap.get(comment.id)!;
      if (comment.parentId) {
        const parent = commentMap.get(comment.parentId);
        if (parent) {
          parent.replies = parent.replies || [];
          parent.replies.push(commentWithReplies);
        }
      } else {
        topLevelComments.push(commentWithReplies);
      }
    });

    return topLevelComments;
  },

  // æ·»åŠ è¯„è®º
  add(comment: Omit<StoredComment, 'id' | 'createdAt'>): StoredComment {
    const comments = this.getAll();
    const newComment: StoredComment = {
      ...comment,
      id: `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString(),
    };
    
    comments.push(newComment);
    window.sessionStorage.setItem(STORAGE_KEYS.POST_COMMENTS, safeStringify(comments));
    
    return newComment;
  },

  // åˆ é™¤è¯„è®º
  remove(commentId: string): boolean {
    const comments = this.getAll();
    const filtered = comments.filter(comment => comment.id !== commentId);
    
    if (filtered.length === comments.length) {
      return false; // æ²¡æœ‰æ‰¾åˆ°è¦åˆ é™¤çš„è¯„è®º
    }
    
    window.sessionStorage.setItem(STORAGE_KEYS.POST_COMMENTS, safeStringify(filtered));
    return true;
  },

  // æ¸…ç©ºæ‰€æœ‰è¯„è®º
  clear(): void {
    window.sessionStorage.removeItem(STORAGE_KEYS.POST_COMMENTS);
  },
};
```

## ğŸ¨ UIç»„ä»¶å®ç°

### 1. CommentItemç»„ä»¶ (`src/components/feed/comment/comment-item.tsx`)

**ç‰¹æ€§ï¼š**
- é€’å½’æ¸²æŸ“åµŒå¥—è¯„è®º
- æ”¯æŒå›å¤åŠŸèƒ½
- æ”¯æŒç‚¹èµåŠŸèƒ½
- æ˜¾ç¤º/éšè—å›å¤
- ä¼˜é›…çš„åŠ¨ç”»æ•ˆæœ
- æœ€å¤š3å±‚åµŒå¥—

```typescript
interface CommentItemProps {
  comment: Comment;
  depth?: number;           // å½“å‰æ·±åº¦
  maxDepth?: number;        // æœ€å¤§æ·±åº¦ï¼ˆé»˜è®¤3ï¼‰
  onReply?: (commentId: string, content: string) => void;
  onLike?: (commentId: string, isLiked: boolean) => void;
  isReplying?: boolean;
}

export const CommentItem = memo<CommentItemProps>(({
  comment,
  depth = 0,
  maxDepth = 3,
  onReply,
  onLike,
  isReplying = false,
}) => {
  const [showReplyInput, setShowReplyInput] = useState(false);
  const [replyText, setReplyText] = useState('');
  const [showReplies, setShowReplies] = useState(true);

  const handleReply = useCallback(() => {
    if (replyText.trim() && onReply) {
      onReply(comment.id, replyText.trim());
      setReplyText('');
      setShowReplyInput(false);
    }
  }, [comment.id, replyText, onReply]);

  const handleLike = useCallback(() => {
    if (onLike) {
      onLike(comment.id, comment.viewer?.liked || false);
    }
  }, [comment.id, comment.viewer?.liked, onLike]);

  const toggleReplies = useCallback(() => {
    setShowReplies(prev => !prev);
  }, []);

  // è®¡ç®—ç¼©è¿›
  const hasReplies = comment.replies && comment.replies.length > 0;
  const canReply = depth < maxDepth;

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: ANIMATION_DURATION.NORMAL }}
      className={cn(
        "py-3",
        depth > 0 && "border-l-2 border-gray-200 dark:border-gray-700 pl-4"
      )}
    >
      {/* è¯„è®ºå†…å®¹ */}
      <div className="flex gap-3">
        {/* å¤´åƒ */}
        <div className="flex-shrink-0">
          <div className="w-8 h-8 rounded-full overflow-hidden">
            {comment.author.avatar ? (
              <img
                src={comment.author.avatar}
                alt={comment.author.displayName}
                className="w-full h-full object-cover"
              />
            ) : (
              <div className="w-full h-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white font-semibold text-xs">
                {comment.author.displayName[0].toUpperCase()}
              </div>
            )}
          </div>
        </div>

        {/* è¯„è®ºä¸»ä½“ */}
        <div className="flex-1 min-w-0">
          {/* ä½œè€…ä¿¡æ¯ */}
          <div className="flex items-center gap-2 mb-1">
            <span className="font-semibold text-[14px] text-gray-900 dark:text-white">
              {comment.author.displayName}
            </span>
            <span className="text-[13px] text-gray-500 dark:text-gray-400">
              @{comment.author.handle}
            </span>
            <span className="text-[12px] text-gray-400 dark:text-gray-500">
              {formatTimeAgo(comment.createdAt)}
            </span>
          </div>

          {/* è¯„è®ºå†…å®¹ */}
          <p className="text-[14px] text-gray-900 dark:text-white leading-relaxed mb-2
          ">
            {comment.content}
          </p>

          {/* æ“ä½œæŒ‰é’® */}
          <div className="flex items-center gap-4">
            {/* å›å¤æŒ‰é’® */}
            {canReply && (
              <button
                onClick={() => setShowReplyInput(!showReplyInput)}
                className="text-[13px] text-gray-500 hover:text-blue-600 dark:hover:text-blue-400 transition-colors font-medium"
              >
                å›å¤
              </button>
            )}

            {/* ç‚¹èµæŒ‰é’® */}
            <button
              onClick={handleLike}
              className={cn(
                "flex items-center gap-1 text-[13px] transition-colors",
                comment.viewer?.liked
                  ? "text-red-500"
                  : "text-gray-500 hover:text-red-500"
              )}
            >
              {comment.viewer?.liked ? (
                <HeartSolid className="w-4 h-4" />
              ) : (
                <HeartOutline className="w-4 h-4" />
              )}
              {comment.stats?.likes && comment.stats.likes > 0 && (
                <span>{comment.stats.likes}</span>
              )}
            </button>

            {/* æ˜¾ç¤º/éšè—å›å¤ */}
            {hasReplies && (
              <button
                onClick={toggleReplies}
                className="text-[13px] text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors font-medium"
              >
                {showReplies ? 'éšè—' : 'æŸ¥çœ‹'} {comment.replyCount} æ¡å›å¤
              </button>
            )}
          </div>

          {/* å›å¤è¾“å…¥æ¡† */}
          <AnimatePresence>
            {showReplyInput && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: ANIMATION_DURATION.FAST }}
                className="mt-3"
              >
                <div className="flex gap-2">
                  <textarea
                    value={replyText}
                    onChange={(e) => setReplyText(e.target.value)}
                    placeholder={`å›å¤ @${comment.author.handle}`}
                    className="flex-1 px-3 py-2 text-[14px] bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg outline-none resize-none focus:border-blue-500 dark:focus:border-blue-400 transition-colors"
                    rows={2}
                    maxLength={280}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                        handleReply();
                      }
                    }}
                  />
                </div>
                <div className="flex items-center justify-between mt-2">
                  <span className="text-[12px] text-gray-500">
                    {replyText.length}/280
                  </span>
                  <div className="flex gap-2">
                    <button
                      onClick={() => {
                        setShowReplyInput(false);
                        setReplyText('');
                      }}
                      className="px-3 py-1 text-[13px] text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200 transition-colors"
                    >
                      å–æ¶ˆ
                    </button>
                    <button
                      onClick={handleReply}
                      disabled={!replyText.trim() || isReplying}
                      className={cn(
                        "px-3 py-1 rounded-full text-[13px] font-semibold transition-all",
                        replyText.trim() && !isReplying
                          ? "bg-blue-600 text-white hover:bg-blue-700"
                          : "bg-gray-200 dark:bg-gray-700 text-gray-400 cursor-not-allowed"
                      )}
                    >
                      {isReplying ? 'å‘é€ä¸­...' : 'å›å¤'}
                    </button>
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>

      {/* åµŒå¥—å›å¤ */}
      <AnimatePresence>
        {showReplies && hasReplies && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: ANIMATION_DURATION.NORMAL }}
            className="mt-2"
          >
            {comment.replies!.map((reply, index) => (
              <CommentItem
                key={reply.id}
                comment={reply}
                depth={depth + 1}
                maxDepth={maxDepth}
                onReply={onReply}
                onLike={onLike}
                isReplying={isReplying}
              />
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
});
```

### 2. CommentListç»„ä»¶ (`src/components/feed/comment/comment-list.tsx`)

```typescript
interface CommentListProps {
  comments: Comment[];
  onReply?: (commentId: string, content: string) => void;
  onLike?: (commentId: string, isLiked: boolean) => void;
  isReplying?: boolean;
  maxDepth?: number;
}

export const CommentList = memo<CommentListProps>(({
  comments,
  onReply,
  onLike,
  isReplying = false,
  maxDepth = 3,
}) => {
  if (!comments || comments.length === 0) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: ANIMATION_DURATION.NORMAL }}
        className="flex flex-col items-center justify-center py-16 text-gray-400"
      >
        <svg
          className="w-16 h-16 mb-4 text-gray-300 dark:text-gray-600"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={1.5}
            d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"
          />
        </svg>
        <p className="text-[15px]">è¿˜æ²¡æœ‰è¯„è®º</p>
        <p className="text-[13px] mt-2 opacity-60">æˆä¸ºç¬¬ä¸€ä¸ªè¯„è®ºçš„äºº</p>
      </motion.div>
    );
  }

  return (
    <div className="divide-y divide-gray-100 dark:divide-gray-800">
      {comments.map((comment, index) => (
        <motion.div
          key={comment.id}
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{
            duration: ANIMATION_DURATION.NORMAL,
            delay: getSequenceDelay(ANIMATION_DELAY.SMALL, index, 0.03),
          }}
        >
          <CommentItem
            comment={comment}
            depth={0}
            maxDepth={maxDepth}
            onReply={onReply}
            onLike={onLike}
            isReplying={isReplying}
          />
        </motion.div>
      ))}
    </div>
  );
});
```

### 3. Postè¯¦æƒ…é¡µé›†æˆ (`src/app/(main)/post/[id]/page.tsx`)

```typescript
export default function PostPage({ params }: PostPageProps) {
  const { id } = use(params);
  const router = useRouter();
  const { user, profile } = useAuth();
  const queryClient = useQueryClient();
  const [commentText, setCommentText] = useState('');

  // Fetch post thread
  const { data, isLoading, isError, refetch, error } = useQuery({
    queryKey: ['post', id],
    queryFn: () => fetchPostThread(id),
  });

  // Comment mutation
  const commentMutation = useMutation({
    mutationFn: async ({ content, parentId }: { content: string; parentId?: string }) => {
      await createComment(id, content, parentId);
    },
    onSuccess: () => {
      setCommentText('');
      queryClient.invalidateQueries({ queryKey: ['post', id] });
    },
  });

  // Comment like mutation
  const commentLikeMutation = useMutation({
    mutationFn: async ({ commentId, isLiked }: { commentId: string; isLiked: boolean }) => {
      const action = isLiked ? 'unlike' : 'like';
      await interactWithComment(commentId, action);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['post', id] });
    },
  });

  // Handle reply to comment
  const handleReply = useCallback((commentId: string, content: string) => {
    if (!user) {
      router.push('/auth');
      return;
    }
    commentMutation.mutate({ content, parentId: commentId });
  }, [user, router, commentMutation]);

  // Handle like comment
  const handleLikeComment = useCallback((commentId: string, isLiked: boolean) => {
    if (!user) {
      router.push('/auth');
      return;
    }
    commentLikeMutation.mutate({ commentId, isLiked });
  }, [user, router, commentLikeMutation]);

  // Convert ThreadPost replies to Comment format
  const convertToComments = useCallback((replies: ThreadPost[]): Comment[] => {
    return replies.map(reply => ({
      id: reply.id,
      userId: reply.author.id,
      targetId: id,
      targetType: 'card' as const,
      type: 'comment' as const,
      content: reply.content,
      parentId: undefined,
      replyCount: reply.replyCount || 0,
      depth: 0,
      author: reply.author,
      createdAt: reply.createdAt,
      replies: reply.replies ? convertToComments(reply.replies) : undefined,
      viewer: reply.viewer ? { liked: reply.viewer.liked } : undefined,
      stats: { likes: reply.stats?.likes || 0 },
    }));
  }, [id]);

  return (
    <div className="min-h-screen bg-[#F5F7FA] dark:bg-[#0A0A0A]">
      {/* Post content */}
      <main className="max-w-2xl mx-auto">
        {/* Post details */}
        <motion.article
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.25 }}
          className="bg-white dark:bg-[#1A1A1A] rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 overflow-hidden"
        >
          {/* Post content */}
        </motion.article>

        {/* Comment Input */}
        {user && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2, duration: 0.2 }}
            className="bg-white dark:bg-[#1A1A1A] rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 p-4 mt-4"
          >
            <div className="flex gap-3">
              <div className="w-10 h-10 rounded-full overflow-hidden flex-shrink-0">
                {profile?.avatar_url ? (
                  <img
                    src={profile.avatar_url}
                    alt={profile.display_name || profile.username}
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div className="w-full h-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white font-semibold">
                    {(profile?.display_name || profile?.username || 'U')[0].toUpperCase()}
                  </div>
                )}
              </div>
              <div className="flex-1">
                <textarea
                  id="comment-input"
                  value={commentText}
                  onChange={(e) => setCommentText(e.target.value)}
                  placeholder="å†™ä¸‹ä½ çš„è¯„è®º..."
                  className="w-full px-4 py-3 text-[15px] bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-xl outline-none resize-none focus:border-blue-500 dark:focus:border-blue-400 transition-colors"
                  rows={3}
                  maxLength={280}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                      handleComment();
                    }
                  }}
                />
                <div className="flex items-center justify-between mt-3">
                  <span className="text-[13px] text-gray-500">
                    {commentText.length}/280
                  </span>
                  <button
                    onClick={handleComment}
                    disabled={!commentText.trim() || commentMutation.isPending}
                    className={cn(
                      "px-4 py-2 rounded-full text-[14px] font-semibold transition-all",
                      commentText.trim() && !commentMutation.isPending
                        ? "bg-blue-600 text-white hover:bg-blue-700"
                        : "bg-gray-200 dark:bg-gray-700 text-gray-400 cursor-not-allowed"
                    )}
                  >
                    {commentMutation.isPending ? 'å‘é€ä¸­...' : 'è¯„è®º'}
                  </button>
                </div>
              </div>
            </div>
          </motion.div>
        )}

        {/* Login prompt for non-authenticated users */}
        {!user && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2, duration: 0.2 }}
            className="bg-white dark:bg-[#1A1A1A] rounded-2xl shadow-sm border border-gray-200 dark:border-gray-800 p-6 mt-4 text-center"
          >
            <p className="text-[15px] text-gray-600 dark:text-gray-400 mb-4">
              ç™»å½•åå³å¯å‚ä¸è®¨è®º
            </p>
            <motion.button
              onClick={() => router.push('/auth')}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
              className="px-6 py-2 bg-blue-600 text-white rounded-full text-[14px] font-semibold hover:bg-blue-700 transition-colors"
            >
              Log in
            </motion.button>
          </motion.div>
        )}

        {/* Comments - Nested comment system */}
        <div className="bg-white dark:bg-[#1A1A1A] px-4">
          <CommentList
            comments={data.replies ? convertToComments(data.replies) : []}
            onReply={handleReply}
            onLike={handleLikeComment}
            isReplying={commentMutation.isPending || commentLikeMutation.isPending}
            maxDepth={3}
          />
        </div>
      </main>
    </div>
  );
}
```

## ğŸ“Š æ•°æ®æµ

### è¯„è®ºåˆ›å»ºæµç¨‹

```
ç”¨æˆ·è¾“å…¥è¯„è®º
    â†“
handleComment() / handleReply()
    â†“
commentMutation.mutate({ content, parentId? })
    â†“
createComment(postId, content, parentId?)
    â†“
Supabase: INSERT INTO interactions
    â†“
è§¦å‘å™¨: update_interaction_reply_count()
    â†“
invalidateQueries(['post', id])
    â†“
é‡æ–°è·å–è¯„è®ºæ ‘
    â†“
UIæ›´æ–°
```

### è¯„è®ºç‚¹èµæµç¨‹

```
ç”¨æˆ·ç‚¹å‡»ç‚¹èµæŒ‰é’®
    â†“
handleLikeComment(commentId, isLiked)
    â†“
commentLikeMutation.mutate({ commentId, isLiked })
    â†“
interactWithComment(commentId, action)
    â†“
Supabase: INSERT/DELETE interactions
    â†“
invalidateQueries(['post', id])
    â†“
é‡æ–°è·å–è¯„è®ºç‚¹èµæ•°æ®
    â†“
UIæ›´æ–°ç‚¹èµçŠ¶æ€
```

### è¯„è®ºæ˜¾ç¤ºæµç¨‹

```
fetchPostThread(postId)
    â†“
è·å–è¯„è®ºæ ‘ï¼ˆåŒ…å«åµŒå¥—ç»“æ„ï¼‰
    â†“
getCommentLikesInfo() è·å–ç‚¹èµæ•°æ®
    â†“
fetchNestedReplies() é€’å½’è·å–åµŒå¥—å›å¤
    â†“
convertToComments() è½¬æ¢æ ¼å¼
    â†“
CommentList æ¸²æŸ“
    â†“
CommentItem é€’å½’æ¸²æŸ“åµŒå¥—è¯„è®º
```

## ğŸ¯ ä¸šå†…æœ€ä½³å®è·µå¯¹æ¯”

### Twitter/X
- âœ… **å³æ—¶åé¦ˆ**ï¼šç‚¹èµåç«‹å³æ›´æ–°UIï¼Œä¸ç­‰å¾…æœåŠ¡å™¨å“åº”
- âœ… **ä¹è§‚æ›´æ–°**ï¼šå…ˆæ›´æ–°æœ¬åœ°çŠ¶æ€ï¼Œå¤±è´¥æ—¶å›æ»š
- âœ… **é˜²æŠ–å¤„ç†**ï¼šé˜²æ­¢é‡å¤ç‚¹å‡»
- âœ… **è§†è§‰åé¦ˆ**ï¼šå¿ƒå½¢å›¾æ ‡å¡«å……åŠ¨ç”»ï¼Œæ•°å­—å˜åŒ–åŠ¨ç”»
- âœ… **åµŒå¥—æ”¯æŒ**ï¼šæ”¯æŒå¤šå±‚å›å¤
- âœ… **çŠ¶æ€æŒä¹…åŒ–**ï¼šåˆ·æ–°é¡µé¢åä¿æŒç‚¹èµçŠ¶æ€
- âœ… **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡åŠ è½½ã€æ·±åº¦é™åˆ¶

### Reddit
- âœ… **åµŒå¥—è¯„è®ºæ”¯æŒ**ï¼šæ¯å±‚è¯„è®ºéƒ½å¯ä»¥ç‹¬ç«‹ç‚¹èµ
- âœ… **ç‚¹èµæ•°æ˜¾ç¤º**ï¼šåªåœ¨æœ‰ç‚¹èµæ—¶æ˜¾ç¤ºæ•°å­—
- âœ… **çŠ¶æ€æŒä¹…åŒ–**ï¼šåˆ·æ–°é¡µé¢åä¿æŒç‚¹èµçŠ¶æ€
- âœ… **æ ‘å½¢ç»“æ„**ï¼šæ¸…æ™°çš„è§†è§‰å±‚æ¬¡
- âœ… **é€’å½’æ¸²æŸ“**ï¼šæ”¯æŒä»»æ„æ·±åº¦
- âœ… **äº¤äº’å®Œæ•´**ï¼šç‚¹èµã€å›å¤åŠŸèƒ½é½å…¨

### YouTube
- âœ… **ç®€æ´è®¾è®¡**ï¼šç‚¹èµæŒ‰é’®ç´§å‡‘ï¼Œä¸å½±å“é˜…è¯»ä½“éªŒ
- âœ… **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡åŠ è½½è¯„è®ºç‚¹èµçŠ¶æ€
- âœ… **é€’å½’åŠ è½½**ï¼šæ”¯æŒæ·±å±‚åµŒå¥—è¯„è®ºçš„ç‚¹èµæ•°æ®
- âœ… **æ‰¹é‡åŠ è½½**ï¼šé«˜æ•ˆçš„è¯„è®ºè·å–
- âœ… **çŠ¶æ€ç®¡ç†**ï¼šReact Queryç¼“å­˜

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åº“å±‚
- âœ… é€’å½’æŸ¥è¯¢ä¼˜åŒ–ï¼ˆCTEï¼‰
- âœ… ç´¢å¼•ä¼˜åŒ–ï¼ˆparent_idç´¢å¼•ï¼‰
- âœ… æ‰¹é‡æ“ä½œï¼ˆè§¦å‘å™¨ï¼‰
- âœ… ä½¿ç”¨ `count: 'exact', head: true` åªè·å–è®¡æ•°ï¼Œä¸è¿”å›æ•°æ®
- âœ… ä½¿ç”¨ `.single()` å¯¹å•æ¡è®°å½•æŸ¥è¯¢è¿›è¡Œä¼˜åŒ–

### 2. APIå±‚
- âœ… æ‰¹é‡ç‚¹èµæ•°æ®æŸ¥è¯¢
- âœ… æ·±åº¦é™åˆ¶ï¼ˆmaxDepth=3ï¼‰
- âœ… é”™è¯¯å¤„ç†å’Œé‡è¯•
- âœ… ä½¿ç”¨é€’å½’å‡½æ•° `fetchNestedReplies` ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰åµŒå¥—è¯„è®ºçš„ç‚¹èµæ•°æ®
- âœ… é¿å…N+1æŸ¥è¯¢é—®é¢˜

### 3. UIå±‚
- âœ… React.memoä¼˜åŒ–
- âœ… useCallbacké¿å…é‡æ¸²æŸ“
- âœ… æ¡ä»¶æ¸²æŸ“ä¼˜åŒ–
- âœ… ä½¿ç”¨ `useCallback` é¿å…ä¸å¿…è¦çš„å‡½æ•°é‡å»º
- âœ… ä½¿ç”¨ `memo` ä¼˜åŒ–ç»„ä»¶æ¸²æŸ“
- âœ… æ¡ä»¶æ¸²æŸ“ç‚¹èµæ•°ï¼ˆåªåœ¨>0æ—¶æ˜¾ç¤ºï¼‰

### 4. çŠ¶æ€ç®¡ç†
- âœ… ä½¿ç”¨ React Query çš„ `useMutation` è¿›è¡ŒçŠ¶æ€ç®¡ç†
- âœ… è‡ªåŠ¨å¤„ç†loadingã€errorçŠ¶æ€
- âœ… æˆåŠŸåè‡ªåŠ¨åˆ·æ–°ç›¸å…³æ•°æ®ï¼ˆ`invalidateQueries`ï¼‰

## ğŸ”’ æ•°æ®ä¸€è‡´æ€§ä¿è¯

### æ•°æ®åº“çº¦æŸ
- âœ… `check_reply_parent`ï¼šreplyå¿…é¡»æœ‰parent_id
- âœ… `check_comment_content`ï¼šè¯„è®ºå¿…é¡»æœ‰å†…å®¹
- âœ… å¤–é”®çº¦æŸï¼šparent_idå¼•ç”¨å®Œæ•´æ€§

### è§¦å‘å™¨
- âœ… `update_interaction_reply_count`ï¼šè‡ªåŠ¨æ›´æ–°reply_count
- âœ… `interaction_stats_trigger`ï¼šè‡ªåŠ¨æ›´æ–°postç»Ÿè®¡

### åº”ç”¨å±‚
- âœ… ç±»å‹å®‰å…¨ï¼ˆTypeScriptï¼‰
- âœ… æ•°æ®éªŒè¯ï¼ˆAPIå±‚ï¼‰
- âœ… é”™è¯¯å¤„ç†ï¼ˆUIå±‚ï¼‰

## ğŸ¨ ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### 1. è§†è§‰åé¦ˆ
- **æœªç‚¹èµ**ï¼šç©ºå¿ƒçº¢å¿ƒå›¾æ ‡ï¼Œç°è‰²
- **å·²ç‚¹èµ**ï¼šå®å¿ƒçº¢å¿ƒå›¾æ ‡ï¼Œçº¢è‰²
- **æ‚¬åœ**ï¼šé¢œè‰²å˜åŒ–ï¼Œæä¾›äº¤äº’æç¤º
- **è¿‡æ¸¡**ï¼šä½¿ç”¨ `transition-colors` å¹³æ»‘è¿‡æ¸¡

### 2. äº¤äº’æµç¨‹
1. ç”¨æˆ·ç‚¹å‡»ç‚¹èµæŒ‰é’®
2. æ£€æŸ¥ç™»å½•çŠ¶æ€ï¼ˆæœªç™»å½•è·³è½¬ç™»å½•é¡µï¼‰
3. å‘èµ·mutationè¯·æ±‚
4. æ˜¾ç¤ºloadingçŠ¶æ€ï¼ˆæŒ‰é’®ç¦ç”¨ï¼‰
5. è¯·æ±‚æˆåŠŸååˆ·æ–°æ•°æ®
6. UIè‡ªåŠ¨æ›´æ–°ä¸ºæœ€æ–°çŠ¶æ€

### 3. é”™è¯¯å¤„ç†
- ç½‘ç»œé”™è¯¯ï¼šReact Queryè‡ªåŠ¨é‡è¯•
- è®¤è¯é”™è¯¯ï¼šè·³è½¬ç™»å½•é¡µ
- é‡å¤ç‚¹èµï¼šæ•°æ®åº“å”¯ä¸€ç´¢å¼•é˜²æ­¢

### 4. æ— éšœç¢æ”¯æŒ
- è¯­ä¹‰åŒ–HTMLï¼ˆbuttonå…ƒç´ ï¼‰
- é€‚å½“çš„hoverçŠ¶æ€
- æ¸…æ™°çš„è§†è§‰åé¦ˆ

### 5. åŠ¨ç”»æ•ˆæœ
- âœ… ä¼˜é›…çš„åŠ¨ç”»æ•ˆæœï¼ˆ150-200msï¼‰
- âœ… åºåˆ—åŠ¨ç”»ï¼ˆ30msé—´éš”ï¼‰
- âœ… åŠ è½½çŠ¶æ€æç¤º
- âœ… ç©ºçŠ¶æ€å‹å¥½æç¤º
- âœ… é”®ç›˜å¿«æ·é”®æ”¯æŒï¼ˆCmd/Ctrl + Enterï¼‰

## ğŸ“Š æµ‹è¯•ç»“æœ

### æ„å»ºæµ‹è¯•
```bash
npm run build
# âœ… Compiled successfully in 3.0s
# âœ… Linting and checking validity of types
# âœ… Generating static pages (8/8)
```

### åŠŸèƒ½æµ‹è¯•æ¸…å•
- [x] åˆ›å»ºé¡¶çº§è¯„è®º
- [x] å›å¤è¯„è®ºï¼ˆäºŒçº§è¯„è®ºï¼‰
- [x] å›å¤çš„å›å¤ï¼ˆä¸‰çº§è¯„è®ºï¼‰
- [x] æ˜¾ç¤º/éšè—åµŒå¥—å›å¤
- [x] è¯„è®ºè®¡æ•°è‡ªåŠ¨æ›´æ–°
- [x] é¡¶å±‚è¯„è®ºç‚¹èµ
- [x] åµŒå¥—è¯„è®ºç‚¹èµï¼ˆ2-3å±‚ï¼‰
- [x] å–æ¶ˆç‚¹èµ
- [x] ç‚¹èµæ•°æ­£ç¡®æ˜¾ç¤º
- [x] ç”¨æˆ·ç‚¹èµçŠ¶æ€æ­£ç¡®æ˜¾ç¤º
- [x] æœªç™»å½•ç”¨æˆ·ç‚¹å‡»è·³è½¬ç™»å½•
- [x] åŠ¨ç”»æ•ˆæœæµç•…
- [x] å“åº”å¼å¸ƒå±€
- [x] æ·±è‰²æ¨¡å¼æ”¯æŒ
- [x] æ ¸å¿ƒåŠŸèƒ½ä¸å—å½±å“

### å…¼å®¹æ€§æµ‹è¯•
- [x] Mockæ¨¡å¼æ­£å¸¸å·¥ä½œ
- [x] Supabaseæ¨¡å¼æ­£å¸¸å·¥ä½œ
- [x] ä¸å½±å“ç°æœ‰postç‚¹èµåŠŸèƒ½
- [x] ä¸å½±å“è¯„è®ºå›å¤åŠŸèƒ½
- [x] ç±»å‹æ£€æŸ¥é€šè¿‡

## ğŸ“ ä½¿ç”¨ç¤ºä¾‹

### åˆ›å»ºé¡¶çº§è¯„è®º
```typescript
await createComment(postId, "è¿™æ˜¯ä¸€æ¡è¯„è®º");
```

### å›å¤è¯„è®º
```typescript
await createComment(postId, "è¿™æ˜¯ä¸€æ¡å›å¤", parentCommentId);
```

### è¯„è®ºç‚¹èµ
```typescript
await interactWithComment(commentId, 'like');
await interactWithComment(commentId, 'unlike');
```

### åœ¨UIä¸­ä½¿ç”¨
```tsx
<CommentList
  comments={comments}
  onReply={(commentId, content) => {
    createComment(postId, content, commentId);
  }}
  onLike={(commentId, isLiked) => {
    interactWithComment(commentId, isLiked ? 'unlike' : 'like');
  }}
  maxDepth={3}
/>
```

## ğŸ”„ æœªæ¥ä¼˜åŒ–æ–¹å‘

### 1. ä¹è§‚æ›´æ–°ï¼ˆOptimistic Updatesï¼‰
```typescript
const commentLikeMutation = useMutation({
  mutationFn: async ({ commentId, isLiked }) => {
    // ...
  },
  onMutate: async ({ commentId, isLiked }) => {
    // ç«‹å³æ›´æ–°UI
    await queryClient.cancelQueries({ queryKey: ['post', id] });
    const previousData = queryClient.getQueryData(['post', id]);
    
    queryClient.setQueryData(['post', id], (old) => {
      // æ›´æ–°è¯„è®ºç‚¹èµçŠ¶æ€
      return updateCommentLikeState(old, commentId, !isLiked);
    });
    
    return { previousData };
  },
  onError: (err, variables, context) => {
    // å¤±è´¥æ—¶å›æ»š
    queryClient.setQueryData(['post', id], context.previousData);
  },
});
```

### 2. æ‰¹é‡è¯·æ±‚ä¼˜åŒ–
- ä½¿ç”¨DataLoaderæ¨¡å¼æ‰¹é‡è·å–ç‚¹èµæ•°æ®
- å‡å°‘æ•°æ®åº“æŸ¥è¯¢æ¬¡æ•°

### 3. ç¼“å­˜ç­–ç•¥
- ä½¿ç”¨React Queryçš„ç¼“å­˜æ—¶é—´é…ç½®
- å®ç°æ›´ç²¾ç»†çš„ç¼“å­˜å¤±æ•ˆç­–ç•¥

### 4. å®æ—¶æ›´æ–°
- ä½¿ç”¨Supabase Realtimeè®¢é˜…ç‚¹èµå˜åŒ–
- å¤šç”¨æˆ·åä½œæ—¶å®æ—¶åŒæ­¥

### 5. åŠ¨ç”»å¢å¼º
- æ·»åŠ ç‚¹èµæ•°å­—å˜åŒ–åŠ¨ç”»
- æ·»åŠ å¿ƒå½¢å›¾æ ‡ç¼©æ”¾åŠ¨ç”»
- æ·»åŠ ç²’å­æ•ˆæœï¼ˆå¯é€‰ï¼‰

### 6. å…¶ä»–åŠŸèƒ½
- è¯„è®ºåˆ é™¤åŠŸèƒ½
- è¯„è®ºç¼–è¾‘åŠŸèƒ½
- è¯„è®ºä¸¾æŠ¥åŠŸèƒ½
- è¯„è®ºæ’åºï¼ˆæŒ‰æ—¶é—´/çƒ­åº¦ï¼‰
- è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¤§é‡è¯„è®ºæ—¶çš„æ€§èƒ½ä¼˜åŒ–ï¼‰
- @æåŠåŠŸèƒ½

## ğŸ“š å‚è€ƒèµ„æ–™

- [Twitter/Xè¯„è®ºç³»ç»Ÿ](https://twitter.com)
- [Redditè¯„è®ºç³»ç»Ÿ](https://reddit.com)
- [YouTubeè¯„è®ºç³»ç»Ÿ](https://youtube.com)
- [PostgreSQLé€’å½’æŸ¥è¯¢](https://www.postgresql.org/docs/current/queries-with.html)
- [Reactæ€§èƒ½ä¼˜åŒ–](https://react.dev/reference/react/memo)
- [Framer MotionåŠ¨ç”»](https://www.framer.com/motion/)
- [React Queryæœ€ä½³å®è·µ](https://tanstack.com/query/latest)

## âœ… æ€»ç»“

åµŒå¥—è¯„è®ºç³»ç»Ÿå·²å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ï¼š

### âœ… å®Œæ•´æ€§
- æ•°æ®åº“schemaå®Œæ•´æ”¯æŒåµŒå¥—ç»“æ„
- APIæ¥å£è¦†ç›–æ‰€æœ‰åŠŸèƒ½éœ€æ±‚
- UIç»„ä»¶é€’å½’æ¸²æŸ“æ­£ç¡®
- ä¸šåŠ¡é€»è¾‘Mockå’ŒSupabaseä¸€è‡´

### âœ… ä¸€è‡´æ€§
- ç±»å‹å®šä¹‰ç»Ÿä¸€
- æ•°æ®æµè½¬æ¢æ­£ç¡®
- çŠ¶æ€ç®¡ç†åŒæ­¥
- é”™è¯¯å¤„ç†å®Œå–„

### âœ… æ€§èƒ½
- æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- æ‰¹é‡æ•°æ®åŠ è½½
- UIæ¸²æŸ“ä¼˜åŒ–
- ç¼“å­˜ç­–ç•¥åˆç†

### âœ… æœ€ä½³å®è·µ
- å‚è€ƒTwitter/Xã€Redditã€YouTubeè®¾è®¡
- ç¬¦åˆReactã€PostgreSQLæœ€ä½³å®è·µ
- ç±»å‹å®‰å…¨ã€é”™è¯¯å¤„ç†å®Œå–„
- ç”¨æˆ·ä½“éªŒæµç•…

**ç»“è®ºï¼šåµŒå¥—è¯„è®ºç³»ç»Ÿå·²å®Œå…¨å®ç°ï¼Œæ‰€æœ‰å±‚é¢è¡¨ç°ä¸€è‡´ï¼Œç¬¦åˆä¸šå†…æœ€ä½³å®è·µï¼** ğŸŠ

æ‰€æœ‰å®ç°å‡ç¬¦åˆä¸šå†…æœ€ä½³å®è·µï¼Œä»£ç è´¨é‡é«˜ï¼Œå¯ç»´æŠ¤æ€§å¼ºï¼Œä¸ºç”¨æˆ·æä¾›äº†æµç•…ã€ç›´è§‚çš„è¯„è®ºäº’åŠ¨ä½“éªŒã€‚
